import fs from "fs";
import path from "path";
import { SOCIAL_CACHE_FOLDER, SOCIAL_CACHE_FILE } from "./identifyNewMatchResults";
import { socialMatchesCache } from "../social/typeCache";
import { mastodonPostStatus, mastodonSearchStatus } from "../social/mastodon";
import { writeToSummary } from "../github/actionSummary";

const CACHE_FILE = path.join(SOCIAL_CACHE_FOLDER, SOCIAL_CACHE_FILE);

// run only if there is a cache file (generated by identifyNewMatchResults)
if (fs.existsSync(CACHE_FILE)) {
	const matches: socialMatchesCache = JSON.parse(fs.readFileSync(CACHE_FILE).toString());

	// filter out old matches which happened too long ago. this ensure the cache file is not endlessly growing
	const preFilterCount = matches.entries.length;
	const filterDateRange = new Date(new Date().getFullYear(), new Date().getMonth() - 2, new Date().getDate());
	matches.entries = matches.entries.filter((entry) => new Date(entry.date) > filterDateRange);
	if (preFilterCount - matches.entries.length != 0) {
		console.log("🧼 " + (preFilterCount - matches.entries.length) + " old entries removed.");
	}

	// Mastodon posting
	const mastodonQueue = async function () {
		// looping through each entry in the cache file
		for (let entry of matches.entries) {
			// start the process and mark the entry

			if (entry.mastodon != "published") {
				console.log("🕵️ attempting to share " + entry.uuid + " to Mastodon.");
				matches.entries.map(() => {
					entry.mastodon = "queued";
				});

				// construct the message we like to post
				const message = entry.league + ": " + entry.team[0] + " - " + entry.team[1] + " (" + entry.score + ")";

				// check if the status has already been posted ❗️ this time range should be larger than the filter
				const checkDateRange = new Date(filterDateRange.setMonth(filterDateRange.getMonth() - 1)); // 1 month older than the filter
				const checkStatusExistance = await mastodonSearchStatus(message); // this is so we can avoid duplicates
				if (checkStatusExistance.status == 200) {
					checkStatusExistance.response.map((response) => {
						// exclude old statuses as the same message may happen in the first/second half of the season or even years later
						if (new Date(response.created_at) > checkDateRange) {
							let consoleNote =
								"🚨 Message has already been shared on " + new Date(response.created_at).toLocaleString("en-GB", { dateStyle: "short" }) + "(" + response.url + "). Marking cache entry as published.";

							console.log(consoleNote);
							writeToSummary(consoleNote);

							matches.entries.map(() => {
								entry.mastodon = "published";
								entry.mastodonUrl = response.url;
							});
						}
					});

					// now process whats left and post the status
					if (entry.mastodon == "queued") {
						console.log("🕵️ " + entry.uuid + " has not been shared. Attempting to do so...");
						const postStatus = await mastodonPostStatus(message); // this will post the message

						if (postStatus.status == 200) {
							let consoleNote = "✅ Post shared successfully: " + postStatus.response.url;
							console.log(consoleNote);
							writeToSummary(consoleNote);
							matches.entries.map(() => {
								entry.mastodon = "published";
								entry.mastodonUrl = postStatus.response.url;
							});
						} else {
							let consoleNote = "🚨 Match " + entry.uuid + " could not be shared! " + postStatus.status;
							console.log(consoleNote);
							writeToSummary(consoleNote);
							throw consoleNote;
						}
					}
				} else {
					throw "Could not verify status existence:" + checkStatusExistance.status;
				}
			} else {
				console.log("✅ " + entry.uuid + " was already shared: " + entry.mastodonUrl);
			}
		}
	};
	// call the mastodonQueue sequentially
	const mastodonProcess = async function () {
		await mastodonQueue();
		fs.writeFileSync(CACHE_FILE, JSON.stringify(matches, null, 2));
	};

	mastodonProcess(); // execue the above async functions
}
